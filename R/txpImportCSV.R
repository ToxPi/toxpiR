##----------------------------------------------------------------------------##
## txpImportCSV
##----------------------------------------------------------------------------##

#' @name txpImportCSV
#' @title Import data file generated by ToxPi Gui or toxpiR Package
#' @description Import data file generated by ToxPi Gui or toxpiR Package
#' 
#' @param csvDataFile Character scalar, the path to a 'data' export from the
#' ToxPi GUI or toxpiR package
#' 
#' @details 
#' This function takes the '_data.csv' files generated by the GUI or R package.
#' See \url{https://toxpi.org} for more information.
#' 
#' Because of the way toxpiR implements transformation functions, there is not
#' a way currently to use the GUI 'hitcount' function. 
#' 
#' @return `list` with `$model` containing [TxpModel] object; `$input` 
#' containing `data.frame` with input data; `$fills` containing a vector 
#' of fill colors.
#' 
#' @importFrom utils type.convert read.csv
#' @export

txpImportCSV <- function(csvDataFile) {
  
  stopifnot(is_scalar_character(csvDataFile))
  stopifnot(file.exists(csvDataFile))
  
  csv <- read.csv(csvDataFile, stringsAsFactors = FALSE, header = FALSE)
  if(inherits(csv[1,1],"character")) {indicator <- csv[1,1]} else {indicator <- NULL}
  if(!is.null(indicator) && indicator != "" && strsplit(indicator, "!")[[1]][1] == "# Generated From toxpiR"){
    res <- try(.fromToxpiR(csv), silent = TRUE)
  } else {
    res <- try(.fromGui(csv), silent = TRUE)
  }
  if (is(res, "try-error")) stop("The given 'csvDataFile' could not be parsed.")
  if (is(res, "simpleCondition")) stop(conditionMessage(res))
  res
  
}

#' @importFrom tidyr separate
#' @importFrom rlang is_scalar_character

.fromToxpiR <- function(csv) {
  # Separate toxpiR indicator value 
  indicator <- csv[1,1]
  invalidIndicatorMsg <- .chkInvalidIndicator(indicator)
  if(!is.null(invalidIndicatorMsg)){return(simpleCondition(invalidIndicatorMsg))}
  negativeHandling <- strsplit(indicator, "!")[[1]][2]
  rankHandling <- strsplit(indicator, "!")[[1]][3]
  
  csv <- csv[-1,]
  
  # Get slice information
  sliceInfoInd <- grepl('^#', csv[ , 1])
  infoNms <- c("name", "wt", "col", "scale")
  sliceInfo <- tidyr::separate(data = csv[sliceInfoInd, ], 
                               col = "V1", 
                               into = infoNms, 
                               sep = "!",
                               extra = "merge",
                               convert = FALSE)
  sliceInfo$name <- sub('^#\\s+', '', sliceInfo$name)
  sliceInfo$col  <- sub('^0x', '#', sliceInfo$col)
  invalidWtMsg <- .chkInvalidWts(sliceInfo$wt, sliceInfo$name)
  if(!is.null(invalidWtMsg)){return(simpleCondition(invalidWtMsg))}
  sliceInfo$wt <- sapply(strsplit(sliceInfo$wt, split = '/'), function(x) {
    as.numeric(x[1]) / as.numeric(ifelse(length(x) == 2, x[2], 1))
  })
  sliceInfo <- sliceInfo[ , infoNms]
  
  invalidColMsg <- .chkInvalidColors(sliceInfo$col)
  if(!is.null(invalidColMsg)){return(simpleCondition(invalidColMsg))}
  invalidFuncMsg <- .chkInvalidFunctions(csv[sliceInfoInd, -1], sliceInfo$scale)
  if(!is.null(invalidFuncMsg)){return(simpleCondition(invalidFuncMsg))}
  emptySliceMsg <- .chkEmptySlices(csv[sliceInfoInd, -1], sliceInfo$name)
  if(!is.null(emptySliceMsg)){return(simpleCondition(emptySliceMsg))}
  
  
  
  #get metric transformation functions (non-empty cells) in slice info header
  sliceInfo$ind <- lapply(1:nrow(csv[sliceInfoInd, -1]), function(i) {
    row <- csv[i, -1]
    inds <- which(sapply(row, .isValidMathFunction, var = "x") | row %in% names(TXP_GUI_FUNCS))
    if (length(inds) == 0) return(NULL)
    inds + 1
  })
  sliceInfo$indLower <- lapply(1:nrow(csv[sliceInfoInd, -1]), function(i) {
    row <- csv[i, -1]
    inds <- which(sapply(row, .isValidMathFunction, var = "l") | row %in% names(TXP_GUI_FUNCS_LOWER))
    if (length(inds) == 0) return(NULL)
    inds + 1
  })
  sliceInfo$indUpper <- lapply(1:nrow(csv[sliceInfoInd, -1]), function(i) {
    row <- csv[i, -1]
    inds <- which(sapply(row, .isValidMathFunction, var = "u") | row %in% names(TXP_GUI_FUNCS_UPPER))
    if (length(inds) == 0) return(NULL)
    inds + 1
  })
  
  # Get the valid expressions corresponding to the functions
  sliceInfo$metricTF <- lapply(1:nrow(csv[sliceInfoInd, -1]), function(i) {
    row <- csv[i, -1]
    valid_exprs <- row[sapply(row, .isValidMathFunction, var = "x") | row %in% names(TXP_GUI_FUNCS)]
    if (length(valid_exprs) == 0) return(NULL)
    valid_exprs
  })
  sliceInfo$metricTFLower <- lapply(1:nrow(csv[sliceInfoInd, -1]), function(i) {
    row <- csv[i, -1]
    valid_exprs <- row[sapply(row, .isValidMathFunction, var = "l") | row %in% names(TXP_GUI_FUNCS_LOWER)]
    if (length(valid_exprs) == 0) return(NULL)
    valid_exprs
  })
  sliceInfo$metricTFUpper <- lapply(1:nrow(csv[sliceInfoInd, -1]), function(i) {
    row <- csv[i, -1]
    valid_exprs <- row[sapply(row, .isValidMathFunction, var = "u") | row %in% names(TXP_GUI_FUNCS_UPPER)]
    if (length(valid_exprs) == 0) return(NULL)
    valid_exprs
  })

  #get raw data
  inputStart <- which(grepl('^row$', csv[ , 1], ignore.case = TRUE))
  if (length(inputStart) != 1) {
    inputStart <- which(csv[ , 1] == '') # Format D
  }
  inputNms <- as.character(csv[inputStart, ])
  input <- csv[(inputStart + 1):nrow(csv), ]
  input[] <- lapply(input, type.convert, as.is = TRUE)
  names(input) <- inputNms
  #input[input < 0] <- NA
  row.names(input) <- 1:nrow(input)
  
  #build the slices
  mkSl <- function(i) {
    #main slice
    if(!is.null(sliceInfo[i, "ind"][[1]])){
      nmsMain <- inputNms[sliceInfo[i, "ind"][[1]]]
      transforms <- paste0("function(x) ", sliceInfo[i, "metricTF"][[1]])
      tfs <- list()
      for(j in 1:length(transforms)){
        func <- sliceInfo[i, "metricTF"][[1]][[j]]
        if(func %in% names(TXP_GUI_FUNCS)){
          newFunc <- TXP_GUI_FUNCS[[func]]
          tfs <- c(tfs, newFunc)
        } else {
          tfs <- c(tfs, eval(parse(text = transforms[j])))
        }
      }
      names(tfs) <- nmsMain
      tfsMain <- do.call(TxpTransFuncList, tfs)
    } else {
      nmsMain <- NULL
      tfsMain <- NULL
    }
      
    #lower confidence interval slice
    if(!is.null(sliceInfo[i, "indLower"][[1]])){
      nmsLower <- inputNms[sliceInfo[i, "indLower"][[1]]]
      transforms <- paste0("function(l) ", sliceInfo[i, "metricTFLower"][[1]])
      tfs <- list()
      for(j in 1:length(transforms)){
        func <- sliceInfo[i, "metricTFLower"][[1]][[j]]
        if(func %in% names(TXP_GUI_FUNCS_LOWER)){
          newFunc <- TXP_GUI_FUNCS_LOWER[[func]]
          tfs <- c(tfs, newFunc)
        } else {
          tfs <- c(tfs, eval(parse(text = transforms[j])))
        }
      }
      names(tfs) <- nmsLower
      tfsLower <- do.call(TxpTransFuncList, tfs)
    } else {
      nmsLower <- NULL
      tfsLower <- NULL
    }
    
    #upper confidence interval slice
    if(!is.null(sliceInfo[i, "indUpper"][[1]])){
      nmsUpper <- inputNms[sliceInfo[i, "indUpper"][[1]]]
      transforms <- paste0("function(u) ", sliceInfo[i, "metricTFUpper"][[1]])
      tfs <- list()
      for(j in 1:length(transforms)){
        func <- sliceInfo[i, "metricTFUpper"][[1]][[j]]
        if(func %in% names(TXP_GUI_FUNCS_UPPER)){
          newFunc <- TXP_GUI_FUNCS_UPPER[[func]]
          tfs <- c(tfs, newFunc)
        } else {
          tfs <- c(tfs, eval(parse(text = transforms[j])))
        }
      }
      names(tfs) <- nmsUpper
      tfsUpper <- do.call(TxpTransFuncList, tfs)
    } else {
      nmsUpper <- NULL
      tfsUpper <- NULL
    }

    #return slice
    TxpSlice(txpValueNames = nmsMain, txpTransFuncs = tfsMain,
             txpLowerNames = nmsLower, txpLowerFuncs = tfsLower,
             txpUpperNames = nmsUpper, txpUpperFuncs = tfsUpper)
  }

  sliceLst <- lapply(seq(nrow(sliceInfo)), mkSl)
  names(sliceLst) <- sliceInfo$name
  sliceLst <- as.TxpSliceList(sliceLst) 
  
  transforms <- paste0("function(x) ", sliceInfo$scale)
  tfs <- list()
  for(j in 1:length(transforms)){
    func <- sliceInfo$scale[[j]]
    if(func %in% names(TXP_GUI_FUNCS)){
      newFunc <- TXP_GUI_FUNCS[[func]]
      tfs <- c(tfs, newFunc)
    } else {
      tfs <- c(tfs, eval(parse(text = transforms[j])))
    }
  }
  names(tfs) <- sliceInfo$name
  
  #ADD SLICE TXPTRANSFUNCS TO MODEL
  model <- TxpModel(txpSlices = sliceLst, 
                    txpWeights = sliceInfo[ , "wt"], 
                    txpTransFuncs = do.call(TxpTransFuncList,tfs),
                    negativeHandling = negativeHandling,
                    rankTies = rankHandling)
  
  vnms <- unique(c(txpValueNames(txpSlices(model), simplify = TRUE),
                   txpLowerNames(txpSlices(model), simplify = TRUE),
                   txpUpperNames(txpSlices(model), simplify = TRUE))
  )
  numCols <- sapply(input[vnms], is.numeric)
  if (!all(numCols)) {
    cols <- paste(vnms[!numCols], collapse = ", ")
    msg <- sprintf(paste("Following input column(s), '%s', could not be",
                         "coerced to numeric."),
                   cols)
    return(simpleCondition(msg))
  }
  
  list(model = model, input = input, fills = sliceInfo$col)
  
}

# Check a string expression for a valid function of a letter
.isValidMathFunction <- function(text, var) {
  expr <- paste0("function(", var, ") ", text)
  
  # Create a clean environment with var <- 1
  env <- new.env(parent = baseenv())
  assign(var, 1, envir = env)  
  
  tryCatch({
    # turn the expression into a function 
    f <- eval(parse(text = expr))
    
    # run the function in the clean env to test for errors
    environment(f) <- env
    f(1)
    
    TRUE
  }, error = function(e) FALSE)
}

.chkInvalidFunctions <- function(data, scale){
  exprs <- unlist(data, use.names = FALSE)
  is_invalid <- nzchar(exprs) & 
    !(sapply(exprs, .isValidMathFunction, var = "x") |
        sapply(exprs, .isValidMathFunction, var = "l") |
        sapply(exprs, .isValidMathFunction, var = "u") |
        exprs %in% names(TXP_GUI_FUNCS) |
        exprs %in% names(TXP_GUI_FUNCS_LOWER) |
        exprs %in% names(TXP_GUI_FUNCS_UPPER))
  invalid_funcs <- unique(exprs[is_invalid])
  
  slice_exprs <- unlist(scale, use.names = FALSE)
  is_invalid <- nzchar(slice_exprs) & 
    !(sapply(slice_exprs, .isValidMathFunction, var = "x") |
        slice_exprs %in% names(TXP_GUI_FUNCS))
  invalid_funcs <- c(invalid_funcs, unique(slice_exprs[is_invalid]))
  
  if (length(invalid_funcs) > 0) {
    msg <- sprintf(
      "The following invalid transformation functions were found in the CSV:\n  %s",
      paste(invalid_funcs, collapse = ", ")
    )
    return(msg)
  } else {
    return(NULL)
  }
}

.chkInvalidColors <- function(cols) {
  invalid <- cols[!sapply(cols, function(col) {
    tryCatch({
      grDevices::col2rgb(col)
      TRUE
    }, error = function(e) FALSE)
  })]
  if (length(invalid) > 0) {
    msg <- sprintf(
      "The following invalid colors were found in the CSV:\n  %s",
      paste(invalid, collapse = ", ")
    )
    return(msg)
  } else {
    return(NULL)
  }
}

.chkEmptySlices <- function(data, sliceNames) {
  row_empty <- vapply(seq_len(nrow(data)), function(i) {
    all(is.na(data[i, ]) | data[i, ] == "")
  }, logical(1))
  
  empty_rows <- which(row_empty)
  if (length(empty_rows) > 0) {
    row_labels <- sliceNames[empty_rows]
    msg <- sprintf(
      "The following slices are empty:\n  %s",
      paste(row_labels, collapse = ", ")
    )
    return(msg)
  } else {
    return(NULL)
  }
}

.chkInvalidIndicator <- function(indicator) {
  validNegHand <- c("keep", "missing")
  validRank <- c("average", "first", "last", "random", "max", "min")
  parts <- strsplit(indicator, "!")[[1]]
  
  msgs <- character()
  
  # Check for correct number of parts
  if (length(parts) != 3) {
    msgs <- c(msgs, sprintf("Invalid file indicator format: expected first cell to be 3 parts separated by '!', got %d.", length(parts)))
  } else {
    neg_hand <- parts[2]
    rank_method <- parts[3]
    
    if (!neg_hand %in% validNegHand) {
      msgs <- c(msgs, sprintf("Invalid negative handling method '%s' in indicator cell. Valid options are: %s",
                              neg_hand, paste(validNegHand, collapse = ", ")))
    }
    
    if (!rank_method %in% validRank) {
      msgs <- c(msgs, sprintf("Invalid rank method '%s' in indicator cell. Valid options are: %s",
                              rank_method, paste(validRank, collapse = ", ")))
    }
  }
  
  if (length(msgs) > 0) {
    return(paste(msgs, collapse = "\n"))
  } else {
    return(NULL)
  }
}

.chkInvalidWts <- function(wts, nms) {
  parsed <- lapply(strsplit(wts, "/"), function(x) {
    num <- suppressWarnings(as.numeric(x[1]))
    den <- suppressWarnings(as.numeric(ifelse(length(x) == 2, x[2], 1)))
    list(num = num, den = den)
  })
  
  invalid <- vapply(parsed, function(x) {
    is.na(x$num) || is.na(x$den) || x$den == 0
  }, logical(1))
  
  if (any(invalid)) {
    bad_slices <- unique(nms[invalid])
    msg <- sprintf(
      "The following slices have invalid weights:\n  %s",
      paste(bad_slices, collapse = ", ")
    )
    return(msg)
  }
  
  return(NULL)
}

#' @importFrom tidyr separate
#' @importFrom rlang is_scalar_character

.fromGui <- function(gui) {
  
  sliceInfoInd <- grepl('^#', gui[ , 1])
  infoNms <- c("name", "wt", "col", "scale")
  sliceInfo <- tidyr::separate(data = gui[sliceInfoInd, ], 
                               col = "V1", 
                               into = infoNms, 
                               sep = "!", 
                               convert = FALSE)
  sliceInfo$name <- sub('^#\\s+', '', sliceInfo$name)
  sliceInfo$col  <- sub('^0x', '#', sliceInfo$col)
  sliceInfo$wt   <- sapply(strsplit(sliceInfo$wt, split = '/'), function(x) {
    as.numeric(x[1]) / as.numeric(ifelse(length(x) == 2, x[2], 1))
  })
  sliceInfo <- sliceInfo[ , infoNms]
  validFuncs <- sliceInfo$scale %in% names(TXP_GUI_FUNCS)
  if (!all(validFuncs)) {
    f <- paste(sliceInfo$scale[!validFuncs], collapse = ", ")
    msg <- sprintf(paste("Given scaling function(s), '%s', not compatible with",
                         "toxpiR. See ?txpImportGui for more information."),
                   f)
    return(simpleCondition(msg))
  }
  sliceInfo$ind <- lapply(seq_len(nrow(gui[sliceInfoInd, ])), function(i) {
    which(gui[sliceInfoInd, ][i, ] == "x")
  })
  
  inputStart <- which(grepl('^row$', gui[ , 1], ignore.case = TRUE))
  if (length(inputStart) != 1) {
    inputStart <- which(gui[ , 1] == '') # Format D
  }
  inputNms <- as.character(gui[inputStart, ])
  input <- gui[(inputStart + 1):nrow(gui), ]
  input[] <- lapply(input, type.convert, as.is = TRUE)
  names(input) <- inputNms
  input[input < 0] <- NA
  row.names(input) <- 1:nrow(input)
  
  mkSl <- function(i) {
    s <- TxpSlice(txpValueNames = inputNms[sliceInfo[i, "ind"][[1]]])
    sl <- length(s)
    tnm <- sliceInfo[i, "scale"]
    tfs <- .repFunc(TXP_GUI_FUNCS[[tnm]], sl)
    names(tfs) <- rep(tnm, sl)
    txpTransFuncs(s) <- tfs
    s
  }
  
  sliceLst <- lapply(seq(nrow(sliceInfo)), mkSl)
  names(sliceLst) <- sliceInfo$name
  sliceLst <- as.TxpSliceList(sliceLst) 
  
  model <- TxpModel(txpSlices = sliceLst, txpWeights = sliceInfo[ , "wt"], negativeHandling = "missing")
  
  vnms <- unique(txpValueNames(txpSlices(model), simplify = TRUE))
  numCols <- sapply(input[vnms], is.numeric)
  if (!all(numCols)) {
    cols <- paste(vnms[!numCols], collapse = ", ")
    msg <- sprintf(paste("Following input column(s), '%s', could not be",
                         "coerced to numeric."),
                   cols)
    return(simpleCondition(msg))
  }
  
  list(model = model, input = input, fills = sliceInfo$col)
  
}

#' @importFrom stats sd

TXP_GUI_FUNCS <- list(
  'linear(x)' = function(x) { x },
  'hit count' = function(x) { as.integer(x != 0) },
  '-log10(x)' = function(x) { ifelse(x <= 0, NA, -log10(x)) },
  '-log10(x)+log10(max(x))' = function(x) {
    ifelse(x <= 0, NA, -log10(x) + log10(max(x, na.rm = TRUE)))
  },
  '-log10(x)+6' = function(x) { ifelse(x <= 0, NA, -log10(x) + 6) },
  '-ln(x)' = function(x) { ifelse(x <= 0, NA, -log(x)) },
  'log10(x)' = function(x) { ifelse(x <= 0, NA, log10(x)) },
  'sqrt(x)' = function(x) { sqrt(x) },
  'zscore(x)' = function(x) { (x - mean(x, na.rm = TRUE))/sd(x, na.rm = TRUE) },
  'uniform(x)' = function(x) {
    xmn <- min(x, na.rm = TRUE)
    xmx <- max(x, na.rm = TRUE)
    (x - xmn)/(xmx - xmn)
  }
)

TXP_GUI_FUNCS_LOWER <- list(
  'linear(l)' = function(l) { l },
  'hit count(l)' = function(l) { as.integer(l != 0) },
  '-log10(l)' = function(l) { ifelse(l <= 0, NA, -log10(l)) },
  '-log10(l)+log10(max(l))' = function(l) {
    ifelse(l <= 0, NA, -log10(l) + log10(max(l, na.rm = TRUE)))
  },
  '-log10(l)+6' = function(l) { ifelse(l <= 0, NA, -log10(l) + 6) },
  '-ln(l)' = function(l) { ifelse(l <= 0, NA, -log(l)) },
  'log10(l)' = function(l) { ifelse(l <= 0, NA, log10(l)) },
  'sqrt(l)' = function(l) { sqrt(l) },
  'zscore(l)' = function(l) { (l - mean(l, na.rm = TRUE))/sd(l, na.rm = TRUE) },
  'uniform(l)' = function(l) {
    xmn <- min(l, na.rm = TRUE)
    xmx <- max(l, na.rm = TRUE)
    (l - xmn)/(xmx - xmn)
  }
)

TXP_GUI_FUNCS_UPPER <- list(
  'linear(u)' = function(u) { u },
  'hit count(u)' = function(u) { as.integer(u != 0) },
  '-log10(u)' = function(u) { ifelse(u <= 0, NA, -log10(u)) },
  '-log10(u)+log10(max(u))' = function(u) {
    ifelse(u <= 0, NA, -log10(u) + log10(max(u, na.rm = TRUE)))
  },
  '-log10(u)+6' = function(u) { ifelse(u <= 0, NA, -log10(u) + 6) },
  '-ln(u)' = function(u) { ifelse(u <= 0, NA, -log(u)) },
  'log10(u)' = function(u) { ifelse(u <= 0, NA, log10(u)) },
  'sqrt(u)' = function(u) { sqrt(u) },
  'zscore(u)' = function(u) { (u - mean(u, na.rm = TRUE))/sd(u, na.rm = TRUE) },
  'uniform(u)' = function(u) {
    xmn <- min(u, na.rm = TRUE)
    xmx <- max(u, na.rm = TRUE)
    (u - xmn)/(xmx - xmn)
  }
)
##----------------------------------------------------------------------------##